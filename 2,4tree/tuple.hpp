#include <iostream>
#include <cstdlib>
#include <sstream>


using namespace std;

#ifndef tuple
#define tuple


////////////////////////////////////////////////////////////////////////////////////////////////////
/// Tuple Class
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! Basically contains two elements. One is a key and other the object to contain.
 */

template <class T, class N>
class Tuple {
	public:
////////////////////////////////////////////////////////////////////////////////////////////////////
/// VARIABLES
////////////////////////////////////////////////////////////////////////////////////////////////////
		T key; /// The key, is used to compare the Tuples. Is a weight to each Tuple object
		N object; /// Is the object itself to be stored in the Tuple
		bool empty; /// A boolean to know if the Tuple has been created empty
////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
/// CONSTRUCTORS / DESTRUCTOR
////////////////////////////////////////////////////////////////////////////////////////////////////
		Tuple (T newKey, N object); /// Constructor, needs the key and the object
		Tuple (); /// Empty constructor
		Tuple (const Tuple &copy); /// Copy constructor
		~Tuple (); /// Destructor
////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////
/// OPERATOR OVERLOADING
////////////////////////////////////////////////////////////////////////////////////////////////////
		
		string toString();
		bool operator<(Tuple const &reference); /// Overload of < operator
		bool operator>(Tuple const &reference); /// Overload of > operator
		bool operator== (Tuple const &reference); /// Overload of == operator
		
		
		template <class Y, class O> 
		friend ostream& operator<< (ostream &out, Tuple<Y,O> print_vec); ///  Overload to print the object
};
#endif


////////////////////////////////////////////////////////////////////////////////////////////////////
/// CONSTRUCTORS / DESTRUCTOR
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T, class N>
Tuple<T,N> :: Tuple (T newKey, N newObject){
	this->key = newKey;
	this->object = newObject;
	this->empty = false;
}

template <class T, class N>
Tuple<T,N> :: Tuple (){
	this->empty = true;
}

template <class T, class N>
Tuple<T,N> :: ~Tuple (){
}

template <class T, class N>
Tuple<T,N> :: Tuple (const Tuple &copy){
	this->key = copy.key;
	this->object = copy.object;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// OVERLOADING OPERATORS
////////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class N>
bool Tuple<T,N> :: operator<(Tuple const &reference){
	return (this->key < reference.key);
}

template <class T, class N>
bool Tuple<T,N> :: operator>(Tuple const &reference){
	return (this->key > reference.key);
}

template <class T, class N>
bool Tuple<T,N> :: operator==(Tuple const &reference){
	return (this->key == reference.key);
}


template <class Y, class O>
ostream& operator<< (ostream &out, Tuple<Y,O> print_vec){
	
	out << "(" << print_vec.key << "," << print_vec.object << ")";
	
	return out;

}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// OTHER FUNCTIONS
////////////////////////////////////////////////////////////////////////////////////////////////////

/// A function to parse a Tuple object 
template <class T, class N>
string Tuple<T,N> :: toString(){
	string result;
	
	result.append("(");
	
	
	stringstream ss;
	ss << this->key;
	string str = ss.str();
	
	result.append(str);
	
	result.append(")");
	
	return result;
}



